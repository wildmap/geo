package geo

import (
	"math"
)

// Triangle represents a triangular polygon in 2D space.
// It stores vertex information, edge IDs, and provides methods for
// geometric operations like point containment testing.
type Triangle struct {
	Index         int64     // Unique identifier for the triangle
	Vertices      []Vertice // The three vertices of the triangle
	EdgeIDs       []int64   // Unique IDs for the three edges (generated by server)
	EdgeKeyString []string  // String keys for the three edges (generated by server)
}

// IsCoordInside determines if a given coordinate point is inside the triangle.
//
// Algorithm (Cross Product Method):
// The triangle's vertices are arranged in counter-clockwise order.
// A point P is inside the triangle if:
//   - All cross products (P->V1) × (P->V2), (P->V2) × (P->V3), (P->V3) × (P->V1)
//     have the same sign (all >= 0 for counter-clockwise vertices)
//
// The method creates vectors from point P to each vertex and checks if
// all cross products are non-negative (>= 0).
//
// Note: Collinear cases (cross product = 0) are considered as being on the
// same side, so points on the triangle boundary are considered inside.
//
// Parameters:
//
//	p - the coordinate point to test
//
// Returns true if the point is inside or on the triangle, false otherwise.
func (t *Triangle) IsCoordInside(p Coord) bool {
	// Create vectors from point p to each of the three vertices
	pa := NewVector(p, t.Vertices[0].Coord)
	pb := NewVector(p, t.Vertices[1].Coord)
	pc := NewVector(p, t.Vertices[2].Coord)

	// Calculate cross product between first two edges
	b1 := pa.Cross(&pb) >= 0
	b2 := pb.Cross(&pc) >= 0

	// If signs differ, point is outside
	if b1 != b2 {
		return false
	}

	// Calculate cross product with third edge
	b3 := pc.Cross(&pa) >= 0

	// Point is inside if all cross products have the same sign
	return b2 == b3
}

// GetIndex returns the unique identifier of the triangle.
func (t *Triangle) GetIndex() int64 {
	return t.Index
}

// GetLocationToBorder determines the spatial relationship between this triangle
// and a given border.
//
// The method first calculates the triangle's bounding rectangle, then
// checks the relationship between that rectangle and the border.
//
// Returns a LocationState indicating whether the triangle is inside, outside,
// or intersecting the border.
func (t *Triangle) GetLocationToBorder(b *Border) LocationState {
	minX, minZ, maxX, maxZ := t.ToRect()
	return b.RectLocation(minX, minZ, maxX, maxZ)
}

// ToRect calculates and returns the axis-aligned bounding rectangle of the triangle.
// This is the smallest rectangle that completely contains the triangle.
//
// Returns:
//
//	minX, minZ - coordinates of the bottom-left corner of the bounding box
//	maxX, maxZ - coordinates of the top-right corner of the bounding box
func (t *Triangle) ToRect() (minX, minZ, maxX, maxZ int64) {
	// Initialize min values to maximum possible int64
	minX = int64(math.MaxInt64)
	minZ = int64(math.MaxInt64)

	// Iterate through all vertices to find min and max coordinates
	for _, v := range t.Vertices {
		minX = min(v.Coord.X, minX)
		minZ = min(v.Coord.Z, minZ)
		maxX = max(v.Coord.X, maxX)
		maxZ = max(v.Coord.Z, maxZ)
	}
	return minX, minZ, maxX, maxZ
}

// GetEdgeIDs returns the list of unique edge IDs for this triangle.
// Each edge has a unique identifier assigned by the server.
func (t *Triangle) GetEdgeIDs() []int64 {
	return t.EdgeIDs
}

// GetEdgeMidCoords calculates and returns the midpoint coordinates of all three edges.
//
// The midpoints are calculated for edges in the following order:
// [0] - midpoint of edge between vertices 0 and 1
// [1] - midpoint of edge between vertices 1 and 2
// [2] - midpoint of edge between vertices 2 and 0
//
// Returns a slice of three Coord values representing the edge midpoints.
func (t *Triangle) GetEdgeMidCoords() []Coord {
	coords := make([]Coord, 3)
	coords[0] = CalMidCoord(t.Vertices[0].Coord, t.Vertices[1].Coord)
	coords[1] = CalMidCoord(t.Vertices[1].Coord, t.Vertices[2].Coord)
	coords[2] = CalMidCoord(t.Vertices[2].Coord, t.Vertices[0].Coord)
	return coords
}

// GetVertices returns the list of all vertices of the triangle.
func (t *Triangle) GetVertices() []Vertice {
	return t.Vertices
}

// GetVectors returns the position vectors of the triangle's vertices.
// Position vectors point from the origin to each vertex.
//
// The vectors are arranged in counter-clockwise order:
// [0] - vector to vertex 0
// [1] - vector to vertex 2
// [2] - vector to vertex 1
//
// Note: The order [0,2,1] instead of [0,1,2] maintains counter-clockwise orientation.
//
// Returns a slice of three Vector values.
func (t *Triangle) GetVectors() []Vector {
	vecs := make([]Vector, 3)

	vecs[0] = NewVectorByCoord(t.Vertices[0].Coord)
	vecs[1] = NewVectorByCoord(t.Vertices[2].Coord)
	vecs[2] = NewVectorByCoord(t.Vertices[1].Coord)

	return vecs
}

// GetNeighborEdgeNums calculates the number of shared edges between this triangle
// and another triangle.
//
// Two triangles share an edge if they have two common vertices.
// This method counts the number of matching vertices between the two triangles.
//
// Parameters:
//
//	t2 - the other triangle to compare with
//
// Returns:
//
//	0 - triangles don't share any vertices (not neighbors)
//	1 - triangles share one vertex (touch at a point)
//	2 - triangles share an edge (adjacent triangles)
//	3 - triangles are identical (all vertices match)
func (t *Triangle) GetNeighborEdgeNums(t2 *Triangle) int {
	var cnt int
	// Compare all vertices of both triangles
	for i := range t.Vertices {
		for j := range t2.Vertices {
			if t.Vertices[i].Index == t2.Vertices[j].Index {
				cnt++
			}
		}
	}
	return cnt
}
